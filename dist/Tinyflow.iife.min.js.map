{"version":3,"file":"Tinyflow.iife.min.js","sources":["../lib/Tinyflow.js"],"sourcesContent":["/**\n * Tinyflow is a minimalistic workflow engine with\n * easy customization.\n * You can use it with any JavaScript runtime as it\n * makes no use of any runtime-specifics.\n * @type {object}\n */\nexport const Tinyflow = {}\n\n// ----------------------------------------------------------------------------\n// Internal Variables\n// ----------------------------------------------------------------------------\nconst _ = {\n  /**\n   * All registered extensions\n   */\n  extensions: new Map(),\n  /**\n   * Contains all created, non-disposed instances\n   */\n  instances: new Map(),\n  /**\n   * The default id generation. You obviously want to use the {Tinyflow.extend} method to bring your own\n   * @private\n   */\n  id: () => Math.random().toString(16).substring(2, 16),\n  /**\n   * Listeners are mapped by emitters\n   * in WeakMap in order to have GC remove them,\n   * if the emitter is cleared\n   * @private\n   * @type {WeakMap<object, any>}\n   */\n  listeners: new WeakMap()\n}\n\n// make available as local variables\n// without the need for the _. prefix\nconst { extensions, listeners, instances } = _\n\n/**\n * Get the listeners for a given emitter.\n * Always returns an array.\n *\n * @private\n * @param emitter {Emitter}\n * @param name {string }\n * @returns {function[]}\n */\nlisteners.by = (emitter, name) => {\n  if (!listeners.has(emitter)) {\n    listeners.set(emitter, new Map())\n  }\n  return listeners.get(emitter).get(name) || []\n}\n\n// ----------------------------------------------------------------------------\n// Public API\n// ----------------------------------------------------------------------------\n/**\n * Extend Tinyflow functionality. In contrast to register an extension this\n * method allows to extend Tinyflows core functionality.\n * @param fn\n */\nTinyflow.extend = fn => fn(_)\n\n/**\n * Gets a workflow instance by its id\n * @method\n * @param id {string}\n * @returns {Workflow}\n */\nTinyflow.get = id => instances.get(id)\n\n/**\n * Returns all non-disposed workflows of any state.\n * @method\n * @return {Workflow[]}\n */\nTinyflow.all = () => [...instances.values()]\n\n/**\n * Clears all extensions and instances. By default, all engines are shut down\n * and fire the end event.\n * @method\n * @param options {object=} options\n * @param options.extensions {boolean=} signal to clear all extensions\n */\nTinyflow.clear = (options = {}) => {\n  const ids = [...instances.keys()]\n  for (const instanceId of ids) {\n    const workflow = Tinyflow.get(instanceId)\n    workflow.cancel()\n    Tinyflow.dispose(instanceId)\n  }\n  if (options.extensions) {\n    extensions.clear()\n  }\n}\n\n/**\n * Register an extension by name. Extensions run on workflow-properties that\n * are not part of the engine core.\n * Core properties are currently: id, next, name, prev\n *\n * Extensions can be registered for workflows and/or steps, which can be determined by\n * the second parameter of their callback.\n *\n * Callbacks can also be async, but they're not awaited (only caught).\n * If callback is null then the extension will be removed.\n *\n * @param name {string} name of the property to register an extension\n * @param handler {null|function(property, context):Promise|void} callback to execute\n */\nTinyflow.use = (name, handler) => {\n  const fn = handler === null ? extensions.delete : extensions.set\n  fn.call(extensions, name, handler)\n}\n\n/**\n * Creates a new workflow instance by given workflow definitions.\n *\n * @param definition {object} the workflow definitions object\n * @returns {Workflow}\n */\nTinyflow.create = (definition) => {\n  const workflow = new Workflow(definition)\n  instances.set(workflow.id, workflow)\n  return workflow\n}\n\n/**\n * Fully disposes a workflow, including any event listener\n * to it, or its current step.\n * Once complete it will finally remove the workflow from\n * the internal instances list.\n * @param instanceId {string}\n * @param force {boolean=}\n */\nTinyflow.dispose = (instanceId, { force = false } = {}) => {\n  const workflow = instances.get(instanceId)\n  if (!workflow) {\n    throw new TinyflowError(`Workflow does not exist by id ${instanceId}`)\n  }\n  if (!force && workflow.state === 'active') {\n    throw new TinyflowError(`Cannot dispose active workflow \"${workflow.name}\"`, { instanceId })\n  }\n  if (workflow.current) {\n    workflow.current.off()\n    workflow.current = null\n  }\n  workflow.off()\n  listeners.delete(workflow)\n  instances.delete(instanceId)\n}\n\n// ----------------------------------------------------------------------------\n// Internal Implementations\n// ----------------------------------------------------------------------------\nconst tick = (fn, t = 0) => setTimeout(fn, t)\nconst promisify = (fn, args) => new Promise((res, rej) => {\n  try {\n    res(fn(...args))\n  } catch (e) {\n    rej(e)\n  }\n})\n\n/**\n * @class\n * A tiny emitter that provides just the bare minimum.\n */\nclass Emitter {\n  /**\n   * returns the size\n   * @return {number}\n   */\n  count () {\n    return listeners.by(this, name).length\n  }\n\n  /**\n   * Attach a new listener\n   * @param name {string}\n   * @param fn {function}\n   */\n  on (name, fn) {\n    let list = listeners.by(this, name)\n    list.push(fn)\n    listeners.get(this).set(name, list)\n  }\n\n  once (name, fn) {\n    fn.once = true\n    this.on(name, fn)\n  }\n\n  /**\n   * Remove listeners. Has multiple combinations:\n   * - if no arg at all is passed will remove **everything**\n   * - if only name is passed will remove all listeners by name\n   * - if name and function is passed will remove only this specific\n   *   listener, if it has been attached before\n   * @param name {string=}\n   * @param fn {function=}\n   */\n  off (name, fn) {\n    if (!name) {\n      listeners.get(this).clear()\n      return // exit\n    }\n    let list = listeners.by(this, name)\n    if (!fn) {\n      list.length = 0\n    }\n    let index = list.length > 0 && list.findIndex((f) => f === fn)\n    if (index > -1) {\n      list.splice(index, 1)\n    } else {\n      throw new TinyflowError(`No listener found by function for event ${name}`, {\n        id: this.id,\n        name: this.name\n      })\n    }\n    listeners.get(this).set(name, list)\n  }\n\n  /**\n   * Fires a new single event for this emitter.\n   * If a listener was registered with the \"once\" flag\n   * then it will only be fired once, then removed\n   * from the listeners list.\n   *\n   * Additional data can be added by an exact single second\n   * argument. Use an object if you have complex data to\n   * submit during the event.\n   * @param name {string} name of the event\n   * @param data {any=} optional data\n   */\n  emit (name, data) {\n    const list = listeners.by(this, name).reverse()\n    for (let i = list.length - 1; i >= 0; i--) {\n      const f = list[i]\n      tick(() => {\n        promisify(f, [data])\n          .catch(e => this.emit('error', { error: e, source: this }))\n      })\n      if (f.once) {\n        list.splice(i, 1)\n      }\n    }\n    listeners.get(this).set(name, list)\n  }\n}\n\n/**\n * A minimal Error extension to add\n * details\n * @class\n */\nclass TinyflowError extends Error {\n  constructor (message, details) {\n    super(message)\n    this.name = 'TinyflowError'\n    this.details = details\n  }\n}\n\nconst runExtensions = ({ workflow, step, onSuccess, onError }) => {\n  const target = workflow || step\n  Promise.all(Object\n      .keys(target.custom)\n      .filter(key => extensions.has(key))\n      .map(name => {\n        const fn = extensions.get(name)\n        const value = target.custom[name]\n        return fn(value, { workflow, step })\n      }))\n    .then(onSuccess)\n    .catch(onError)\n}\n\n/**\n * The main workflow execution class,\n * defined by the given definitions file.\n *\n * Initial state is pending, until `start()` is called.\n * Hooks will not run when pending.\n *\n * Next step is defined either by `next` being defined in the current step\n * or by user explicitly set the name or index of the step.\n * It's up to you to handle permissions for any of these methods.\n *\n * Emits various events, see the respective method documentation.\n *\n * @class\n * @see {Tinyflow.create}\n */\nexport class Workflow extends Emitter {\n\n  /**\n   * Creates a new instance. Any properties in the definitions, hat are not\n   * one of name, id or steps are considered \"custom\" and are (optionally) handled\n   * by their respective extensions (if registered).\n   *\n   * @constructor\n   * @param name {string} name of the workflow\n   * @param id {string} identifier of this instance of the workflow (in case you run multiple of the same)\n   * @param steps {object} the workflows step definitions\n   * @param custom {object} contains all custom properties of this workflow's definitions\n   * @see {Tinyflow.use}\n   * @throws {TinyflowError} if steps are not defined or have length of 0\n   */\n  constructor ({ name, id, steps = {}, ...custom }) {\n    super()\n    this.name = name\n    this.id = id || _.id()\n    this.data = null\n    this.state = 'pending'\n    this.custom = {}\n    this.history = []\n\n    // parse extensions\n    const stepExt = {}\n    Object.entries(custom).forEach(([key, val]) => {\n      // if extensions are not defined as array, we\n      // assume them to run in global scope\n      const [fn, scope] = Array.isArray(val) ? val : [val, 'all']\n\n      // attach extensions for workflows directly\n      if (['all', 'workflow'].includes(scope)) {\n        this.custom[key] = fn\n      }\n      // attach extensions for steps to temp object,\n      // so we can use them in the step parsing\n      // note, that if a step defines the extensions as null\n      // then it will prevent this extension for this step\n      if (['all', 'steps'].includes(scope)) {\n        stepExt[key] = fn\n      }\n    })\n\n    this.steps = Object\n      .entries(steps)\n      .map(([name, value], index, array) => {\n        const next = index < array.length - 1\n          ? index + 1\n          : null\n        return { next, name, ...stepExt, ...value }\n      })\n\n    if (this.steps.length === 0) {\n      throw new TinyflowError(\n        'Workflow steps must have at least one entry, got 0',\n        { name, id }\n      )\n    }\n\n    /**\n     * The current step\n     * @type {Step|null}\n     */\n    this.current = null\n  }\n\n  /**\n   * Starts the workflow, runs through all extensions.\n   * Extensions are caught in a separate Microtask (Promise.catch) and will\n   * not cause the workflow start to cancel.\n   * Sets thw workflow state to \"active\"\n   * @emits started - when the workflow instance has successfully started (state became 'active')\n   * @param {autoStep=} if set to false it will not automatically step into the first available step\n   * @throws {TinyflowError} if the state is other than \"pending\"\n   */\n  start ({ autoStep } = {}) {\n    if (this.state === 'active') {\n      throw new TinyflowError(\n        `Cannot start active workflow`,\n        { name: this.name, id: this.id }\n      )\n    }\n    this.data = Object.create(null)\n    const workflow = this\n\n    runExtensions({\n      workflow,\n      onSuccess: () => {\n        this.state = 'active'\n        this.emit('started', this)\n        if (autoStep !== false) {\n          this.step(0)\n        }\n      },\n      onError: e => this.emit('error', { error: e, workflow })\n    })\n  }\n\n  /**\n   * Sets a given step by name or index as the new current one.\n   * This method is for manually setting the next step.\n   * If you want the engine to automatically set the next step you\n   * should rather end the current step using step.complete or step.cancel\n   *\n   * When a new step is set, the current step will be disposed properly,\n   * so you don't have to do it.\n   *\n   * Will listen to the new step's \"end\" event and automatically\n   * determine the next step to choose or to end the workflow.\n   *\n   * @param indexOrName {string|number|null} index of the step in linear flows or name of the step in non-linear flows\n   * @param options {object=}\n   * @param options.stepId {string=} an optional\n   * @param options.autoOnEnd {boolean=} set to true to prevent workflow from automatically handling the next step\n   *   if the current step ends\n   * @emits step - when the new step is properly set up and active\n   * @throws {TinyflowError} if no step is found by index or name\n   */\n  step (indexOrName, { stepId, autoOnEnd } = {}) {\n    if (this.state !== 'active') {\n      throw new TinyflowError(\n        `Can only step in an active state, got \"${this.state}\"`,\n        { indexOrName, name: this.name, id: this.id }\n      )\n    }\n\n    let stepDef = typeof indexOrName === 'number'\n      ? this.steps[indexOrName]\n      : this.steps.find(({ name }) => name === indexOrName)\n\n    if (!stepDef) {\n      throw new TinyflowError(\n        `Expected step definition, got ${stepDef}`,\n        { indexOrName, name: this.name, id: this.id }\n      )\n    }\n\n    const id = stepId || _.id()\n    const workflowId = this.id\n    const step = new Step({ id, workflowId, ...stepDef })\n    const workflow = this\n    const endStep = (step) => {\n      if (step) {\n        step.off()\n        // for a most simple audit we save a minimal set of data\n        // that allows for reproduction or implementing a \"back to previous\"\n        // procedure, for example using extensions or other externals\n        this.history.push({ name: step.name, data: { ...step.data }, at: new Date() })\n      }\n      return true\n    }\n\n    if (autoOnEnd !== false) {\n      step.once('end', (step) => {\n        workflow.data[step.name] = { ...step.data }\n\n        const next = step.next\n        return (next !== null && next <= workflow.steps.length - 1)\n          ? tick(() => workflow.step(next))\n          : endStep(step) && workflow.complete()\n      })\n    }\n\n    step.start()\n    endStep(this.current)\n    this.current = step\n    this.emit('step', this)\n  }\n\n  /**\n   * Completes the workflow, sets the current step to null\n   * and the state to \"complete\".\n   * Does not delete the workflow data as opposed to the cancel event\n   * @emits end - the workflow has ended, see the state property for in which state it ended\n   */\n  complete () {\n    if (this.current) {\n      this.current.off()\n    }\n    this.current = null\n    this.state = 'complete'\n    this.emit('end', this)\n  }\n\n  /**\n   *\n   *Completes the workflow but also wiped it's data\n   * and sets state as \"cancelled\"\n   * @emits end - the workflow has ended, see the state property for in which state it ended\n   */\n  cancel () {\n    if (this.current) {\n      this.current.off()\n    }\n    this.data = null\n    this.current = null\n    this.state = 'complete'\n    this.emit('end', this)\n  }\n}\n\n/**\n * Represents an executable unit of a workflow.\n * Steps work best when they are atomically related to exactly one\n * task. It is up to the user to define and implement what such\n * a task might be.\n * Examples of tasks can be fetching data from an endpoint or\n * users submitting a form.\n * Just make sure a step does not involve multiple tasks.\n * @class\n */\nexport class Step extends Emitter {\n  /**\n   * Creates a new step instance\n   * @constructor\n   * @param id {string}\n   * @param workflowId {string}\n   * @param name {string}\n   * @param data {object=} optional data from start of the workflow\n   * @param next {string|number|undefined}\n   * @param custom {...object} all other properties that will be passed on to your custom handlers\n   */\n  constructor ({ id, workflowId, name, data = null, next, ...custom }) {\n    super()\n    this.id = id || _.id()\n    this.workflowId = workflowId\n    this.name = name\n    this.next = next\n    this.custom = custom\n    this.state = 'pending'\n    this.data = data\n  }\n\n  /**\n   * Starts the step, changing its state from 'pending' to active.\n   *\n   * Note: This method is usually called by the workflow automatically. You\n   * should by default not have the need to call this method.\n   *\n   * Runs through all extensions.\n   *\n   * Extensions are caught in a separate Microtask (Promise.catch) and will\n   * not cause the step-start to cancel.\n   *\n   * @emits started - when the step instance has successfully started (state became 'active')\n   * @throws {TinyflowError} if the current state is other than \"pending\"\n   */\n  start () {\n    if (this.state === 'active') {\n      throw new TinyflowError(\n        `Cannot start a step in active state`,\n        { name: this.name, id: this.id, wf: this.workflowId }\n      )\n    }\n\n    this.data = this.data || Object.create(null)\n    const step = this\n\n    runExtensions({\n      step,\n      onSuccess: () => {\n        this.state = 'active'\n        this.emit('started', this)\n      },\n      onError: e => this.emit('error', { error: e, step })\n    })\n  }\n\n  /**\n   * Updates the step's data (hard-override!)\n   * Use it's existing data to merge\n   * @example\n   * step.update({ foo: 1 }) // { foo: 1}\n   * step.update({ bar: 2, ...step.data }) // { foo: 1, bar: 2 }\n   * @param data {object}\n   * @emits update - the step's data has updated\n   */\n  update (data) {\n    this.data = Object.create(null)\n    Object.assign(this.data, data)\n    this.emit('update', this)\n  }\n\n  /**\n   * Sets the workflow state to 'complete'\n   * @emits end - the workflow has ended, see state for the way it ended\n   */\n  complete () {\n    this.state = 'complete'\n    this.emit('end', this)\n  }\n\n  /**\n   * Sets the workflow state to 'cancelled' and wipes the data\n   * @emits end - the workflow has ended, see state for the way it ended\n   */\n  cancel () {\n    this.state = 'cancelled'\n    this.data = null\n    this.emit('end', this)\n  }\n}\n\n"],"names":["Tinyflow","_","extensions","Map","instances","id","Math","random","toString","substring","listeners","WeakMap","by","emitter","name","has","set","get","extend","fn","all","_toConsumableArray","values","clear","_step","options","arguments","length","undefined","_iterator","_createForOfIteratorHelper","keys","s","n","done","instanceId","value","cancel","dispose","err","e","f","use","handler","call","create","definition","workflow","Workflow","_ref$force","force","TinyflowError","concat","state","current","off","tick","setTimeout","Emitter","_classCallCheck","_createClass","key","this","list","push","once","on","index","findIndex","splice","data","_this","reverse","_loop","i","args","Promise","res","rej","apply","emit","error","source","_Error","_inherits","_super","_createSuper","message","details","_this2","_wrapNativeSuper","Error","runExtensions","_ref2","step","onSuccess","onError","target","Object","custom","filter","map","then","_Emitter","_super2","_ref3","_this3","_ref3$steps","steps","_objectWithoutProperties","_excluded","history","stepExt","entries","forEach","_ref4","_ref5","_slicedToArray","val","_ref7","Array","isArray","scope","includes","_ref8","array","_ref9","_objectSpread","next","_this4","autoStep","indexOrName","_this5","_ref11","stepId","autoOnEnd","stepDef","find","_ref12","workflowId","Step","endStep","at","Date","complete","start","_Emitter2","_super3","_ref13","_this6","_ref13$data","_excluded2","_this7","wf","assign","exports"],"mappings":"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"}