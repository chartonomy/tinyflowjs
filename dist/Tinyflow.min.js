const t={},e={extensions:new Map,instances:new Map,id:()=>Math.random().toString(16).substring(2,16),listeners:new WeakMap},{extensions:s,listeners:i,instances:n}=e;i.by=(t,e)=>(i.has(t)||i.set(t,new Map),i.get(t).get(e)||[]),t.extend=t=>t(e),t.get=t=>n.get(t),t.all=()=>[...n.values()],t.clear=(e={})=>{const i=[...n.keys()];for(const e of i){t.get(e).cancel(),t.dispose(e)}e.extensions&&s.clear()},t.use=(t,e)=>{(null===e?s.delete:s.set).call(s,t,e)},t.create=t=>{const e=new c(t);return n.set(e.id,e),e},t.dispose=(t,{force:e=!1}={})=>{const s=n.get(t);if(!s)throw new o(`Workflow does not exist by id ${t}`);if(!e&&"active"===s.state)throw new o(`Cannot dispose active workflow "${s.name}"`,{instanceId:t});s.current&&(s.current.off(),s.current=null),s.off(),i.delete(s),n.delete(t)};const a=(t,e=0)=>setTimeout(t,e);class r{count(){return i.by(this,name).length}on(t,e){let s=i.by(this,t);s.push(e),i.get(this).set(t,s)}once(t,e){e.once=!0,this.on(t,e)}off(t,e){if(!t)return void i.get(this).clear();let s=i.by(this,t);e||(s.length=0);let n=s.length>0&&s.findIndex((t=>t===e));if(!(n>-1))throw new o(`No listener found by function for event ${t}`,{id:this.id,name:this.name});s.splice(n,1),i.get(this).set(t,s)}emit(t,e){const s=i.by(this,t).reverse();for(let t=s.length-1;t>=0;t--){const i=s[t];a((()=>{var t,s;(t=i,s=[e],new Promise(((e,i)=>{try{e(t(...s))}catch(t){i(t)}}))).catch((t=>this.emit("error",{error:t,source:this})))})),i.once&&s.splice(t,1)}i.get(this).set(t,s)}}class o extends Error{constructor(t,e){super(t),this.name="TinyflowError",this.details=e}}const h=({workflow:t,step:e,onSuccess:i,onError:n})=>{const a=t||e;Promise.all(Object.keys(a.custom).filter((t=>s.has(t))).map((i=>s.get(i)(a.custom[i],{workflow:t,step:e})))).then(i).catch(n)};class c extends r{constructor({name:t,id:s,steps:i={},...n}){super(),this.name=t,this.id=s||e.id(),this.data=null,this.state="pending",this.custom={},this.history=[];const a={};if(Object.entries(n).forEach((([t,e])=>{const[s,i]=Array.isArray(e)?e:[e,"all"];["all","workflow"].includes(i)&&(this.custom[t]=s),["all","steps"].includes(i)&&(a[t]=s)})),this.steps=Object.entries(i).map((([t,e],s,i)=>({next:s<i.length-1?s+1:null,name:t,...a,...e}))),0===this.steps.length)throw new o("Workflow steps must have at least one entry, got 0",{name:t,id:s});this.current=null}start({autoStep:t}={}){if("active"===this.state)throw new o("Cannot start active workflow",{name:this.name,id:this.id});this.data=Object.create(null);const e=this;h({workflow:e,onSuccess:()=>{this.state="active",this.emit("started",this),!1!==t&&this.step(0)},onError:t=>this.emit("error",{error:t,workflow:e})})}step(t,{stepId:s,autoOnEnd:i}={}){if("active"!==this.state)throw new o(`Can only step in an active state, got "${this.state}"`,{indexOrName:t,name:this.name,id:this.id});let n="number"==typeof t?this.steps[t]:this.steps.find((({name:e})=>e===t));if(!n)throw new o(`Expected step definition, got ${n}`,{indexOrName:t,name:this.name,id:this.id});const r=s||e.id(),h=this.id,c=new l({id:r,workflowId:h,...n}),d=this,u=t=>(t&&(t.off(),this.history.push({name:t.name,data:{...t.data},at:new Date})),!0);!1!==i&&c.once("end",(t=>{d.data[t.name]={...t.data};const e=t.next;return null!==e&&e<=d.steps.length-1?a((()=>d.step(e))):u(t)&&d.complete()})),c.start(),u(this.current),this.current=c,this.emit("step",this)}complete(){this.current&&this.current.off(),this.current=null,this.state="complete",this.emit("end",this)}cancel(){this.current&&this.current.off(),this.data=null,this.current=null,this.state="complete",this.emit("end",this)}}class l extends r{constructor({id:t,workflowId:s,name:i,data:n=null,next:a,...r}){super(),this.id=t||e.id(),this.workflowId=s,this.name=i,this.next=a,this.custom=r,this.state="pending",this.data=n}start(){if("active"===this.state)throw new o("Cannot start a step in active state",{name:this.name,id:this.id,wf:this.workflowId});this.data=this.data||Object.create(null);const t=this;h({step:t,onSuccess:()=>{this.state="active",this.emit("started",this)},onError:e=>this.emit("error",{error:e,step:t})})}update(t){this.data=Object.create(null),Object.assign(this.data,t),this.emit("update",this)}complete(){this.state="complete",this.emit("end",this)}cancel(){this.state="cancelled",this.data=null,this.emit("end",this)}}export{l as Step,t as Tinyflow,c as Workflow};//# sourceMappingURL=Tinyflow.min.js.map
